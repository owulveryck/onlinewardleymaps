<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OWM Renderer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        /* Basic Wardley Map styles */
        .wardley {
            background: linear-gradient(to right, #F5F5F5 0%, #E0E0E0 100%);
        }
        .plain {
            background: white;
        }
    </style>
    <!-- Load React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
</head>
<body>
    <div id="map-container"></div>

    <script type="module">
        // This function will be called by Playwright after injecting the OWM text
        window.renderOWM = async function() {
            const owmText = window.OWM_TEXT || '';
            const width = window.OWM_WIDTH || 500;
            const height = window.OWM_HEIGHT || 600;

            if (!owmText) {
                console.error('No OWM text provided');
                return;
            }

            // Import the converter from the parent frontend source
            const { UnifiedConverter } = await import('../../src/conversion/UnifiedConverter.js');
            const { EvolutionStages: DefaultEvolutionStages, EvoOffsets } = await import('../../src/constants/defaults.js');

            // Create a converter instance
            const converter = new UnifiedConverter({});

            let wardleyMap;
            try {
                wardleyMap = converter.parse(owmText);
            } catch (error) {
                console.error('Failed to parse OWM text:', error);
                throw error;
            }

            // Extract map title
            const mapTitle = wardleyMap.presentation?.title || 'Untitled Map';

            // Determine map style from the OWM text
            let styleClass = 'plain';
            const styleMatch = owmText.match(/style\s+(\w+)/);
            if (styleMatch) {
                styleClass = styleMatch[1];
            }

            // Apply style to container
            const container = document.getElementById('map-container');
            container.className = styleClass;
            container.style.width = `${width}px`;
            container.style.height = `${height}px`;

            // Create a simple SVG representation of the map
            renderSimpleSVG(wardleyMap, width, height, styleClass);
        };

        // Simplified SVG renderer
        function renderSimpleSVG(map, width, height, styleClass) {
            const container = document.getElementById('map-container');

            // Map dimensions and padding
            const padding = { left: 50, right: 50, top: 50, bottom: 50 };
            const mapWidth = width - padding.left - padding.right;
            const mapHeight = height - padding.top - padding.bottom;

            // Create SVG
            let svgContent = `
                <svg id="svgMap" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                    <!-- Background -->
                    ${styleClass === 'wardley' ? `
                    <defs>
                        <linearGradient id="wardleyGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#F5F5F5;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#E0E0E0;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <rect width="${width}" height="${height}" fill="url(#wardleyGradient)"/>
                    ` : `<rect width="${width}" height="${height}" fill="white"/>`}

                    <!-- Grid lines -->
                    <g id="grid" stroke="#ccc" stroke-width="0.5">
                        ${Array.from({length: 5}, (_, i) => {
                            const x = padding.left + (mapWidth * i / 4);
                            return `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" />`;
                        }).join('')}
                    </g>

                    <!-- Evolution axis -->
                    <g id="evolution-axis">
                        <line x1="${padding.left}" y1="${height - padding.bottom}"
                              x2="${width - padding.right}" y2="${height - padding.bottom}"
                              stroke="black" stroke-width="2"/>

                        <!-- Evolution labels -->
                        <text x="${padding.left + mapWidth * 0.125}" y="${height - padding.bottom + 30}"
                              text-anchor="middle" font-size="12">Genesis</text>
                        <text x="${padding.left + mapWidth * 0.375}" y="${height - padding.bottom + 30}"
                              text-anchor="middle" font-size="12">Custom Built</text>
                        <text x="${padding.left + mapWidth * 0.625}" y="${height - padding.bottom + 30}"
                              text-anchor="middle" font-size="12">Product</text>
                        <text x="${padding.left + mapWidth * 0.875}" y="${height - padding.bottom + 30}"
                              text-anchor="middle" font-size="12">Commodity</text>
                    </g>

                    <!-- Value chain axis -->
                    <g id="value-chain-axis">
                        <line x1="${padding.left}" y1="${padding.top}"
                              x2="${padding.left}" y2="${height - padding.bottom}"
                              stroke="black" stroke-width="2"/>

                        <text x="${padding.left - 30}" y="${padding.top + 10}"
                              text-anchor="middle" font-size="12" writing-mode="tb">Value Chain</text>
                    </g>

                    <!-- Title -->
                    ${map.presentation?.title ? `
                    <text x="${width / 2}" y="${padding.top - 20}"
                          text-anchor="middle" font-size="16" font-weight="bold">${escapeHtml(map.presentation.title)}</text>
                    ` : ''}

                    <!-- Links (draw first so components appear on top) -->
                    <g id="links">
                        ${(map.links || []).map(link => {
                            const from = (map.elements || []).find(e => e.id === link.start);
                            const to = (map.elements || []).find(e => e.id === link.end);
                            if (!from || !to) return '';

                            const x1 = padding.left + from.maturity * mapWidth;
                            const y1 = padding.top + (1 - from.visibility) * mapHeight;
                            const x2 = padding.left + to.maturity * mapWidth;
                            const y2 = padding.top + (1 - to.visibility) * mapHeight;

                            return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"
                                          stroke="#666" stroke-width="2" opacity="0.6"/>`;
                        }).join('')}
                    </g>

                    <!-- Components -->
                    <g id="components">
                        ${(map.elements || []).map(element => {
                            const x = padding.left + element.maturity * mapWidth;
                            const y = padding.top + (1 - element.visibility) * mapHeight;
                            const isAnchor = element.type === 'anchor';
                            const radius = isAnchor ? 8 : 10;
                            const fill = isAnchor ? '#FF6B6B' : '#4ECDC4';

                            return `
                                <circle cx="${x}" cy="${y}" r="${radius}"
                                        fill="${fill}" stroke="#333" stroke-width="2"/>
                                <text x="${x}" y="${y - 15}"
                                      text-anchor="middle" font-size="11" font-weight="bold">${escapeHtml(element.name)}</text>
                            `;
                        }).join('')}
                    </g>

                    <!-- Annotations -->
                    ${(map.annotations || []).map(annotation => {
                        if (annotation.occurances && annotation.occurances.length > 0) {
                            const occ = annotation.occurances[0];
                            const x = padding.left + occ.maturity * mapWidth;
                            const y = padding.top + (1 - occ.visibility) * mapHeight;

                            return `
                                <g>
                                    <rect x="${x}" y="${y}" width="150" height="60"
                                          fill="#FFF9C4" stroke="#FBC02D" stroke-width="1" opacity="0.9" rx="5"/>
                                    <text x="${x + 5}" y="${y + 15}" font-size="10" font-weight="bold">${annotation.number}</text>
                                    <text x="${x + 5}" y="${y + 30}" font-size="9">${escapeHtml(annotation.text.substring(0, 30))}...</text>
                                </g>
                            `;
                        }
                        return '';
                    }).join('')}
                </svg>
            `;

            container.innerHTML = svgContent;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
